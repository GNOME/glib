<?xml version='1.0' encoding="ISO-8859-1"?>
  <chapter>
    <title>The Glib Dynamic Type System</title>

      <para>
	A type, as manipulated by the Glib type system, is much more generic than what
	is usually understood as an Object type. It is best explained by looking at the 
	structure and the functions used to register new types in the type system.
	<programlisting>
typedef struct _GTypeInfo               GTypeInfo;
struct _GTypeInfo
{
  /* interface types, classed types, instantiated types */
  guint16                class_size;
  
  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;
  
  /* classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;
  
  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;
  
  /* value handling */
  const GTypeValueTable *value_table;
};
GType g_type_register_static (GType             parent_type,
                              const gchar      *type_name,
                              const GTypeInfo  *info,
                              GTypeFlags        flags);
GType g_type_register_fundamental (GType                       type_id,
                                   const gchar                *type_name,
                                   const GTypeInfo            *info,
                                   const GTypeFundamentalInfo *finfo,
                                   GTypeFlags                  flags);
	</programlisting>
      </para>

      <para>
	<function>g_type_register_static</function> and 
	<function>g_type_register_fundamental</function>
	are the C functions, defined in
	<filename>gtype.h</filename> and implemented in <filename>gtype.c</filename>
	which you should use to register a new type in the program's type system.
	It is not likely you will ever need to use 
	<function>g_type_register_fundamental</function> (you have to be Tim Janik 
	to do that) but in case you want to, the last chapter explains how to create
	new fundamental types.
	<footnote>
	  <para>
	    Please, note that there exist another registration function: the 
	    <function>g_type_register_dynamic</function>. We will not discuss this
	    function here since its use is very similar to the <function>_static</function> 
	    version.
	  </para>
	</footnote>
      </para>

      <para>
	Fundamental types are top-level types which do not derive from any other type 
	while other non-fundamental types derive from other types.
	Upon initialization by <function>g_type_init</function>, the type system not 
	only initializes its internal data structures but it also registers a number of core
	types: some of these are fundamental types. Others are types derived from these 
        fundamental types.
      </para>

      <para>
	Fundamental and non-Fundamental types are defined by:
	<itemizedlist>
	  <listitem><para>
	      class size: the class_size field in <type>GTypeInfo</type>.
	    </para></listitem>
	  <listitem><para>
	      class initialization functions (C++ constructor): the base_init and 
	      class_init fields in <type>GTypeInfo</type>.
	    </para></listitem>
	  <listitem><para>
	      class destruction functions (C++ destructor): the base_finalize and 
	      class_finalize fields in <type>GTypeInfo</type>.
	    </para></listitem>
	  <listitem><para>
	      instance size (C++ parameter to new): the instance_size field in 
	      <type>GTypeInfo</type>.
	    </para></listitem>
	  <listitem><para>
	      instanciation policy (C++ type of new operator): the n_preallocs
	      field in <type>GTypeInfo</type>.
	    </para></listitem>
	  <listitem><para>
	      copy functions (C++ copy operators): the value_table field in 
	      <type>GTypeInfo</type>.
	    </para></listitem>
	<listitem><para>
	    XXX: <type>GTypeFlags</type>.
	  </para></listitem>
	</itemizedlist>
      Fundamental types are also defined by a set of <type>GTypeFundamentalFlags</type> 
      which are stored in a <type>GTypeFundamentalInfo</type>.
      Non-Fundamental types are furthermore defined by the type of their parent which is
      passed as the parent_type parameter to <function>g_type_register_static</function>
      and <function>g_type_register_dynamic</function>.
      </para>
      
      <sect1 id="gtype-copy">
	<title>Copy functions</title>

	<para>
	  The major common point between <emphasis>all</emphasis> glib types (fundamental and 
	  non-fundamental, classed and non-classed, instantiable and non-instantiable) is that
	  they can all be manipulated through a single API to copy/assign them.
	</para>

	<para>
	  The <type>GValue</type> structure is used as an abstract container for all of these 
	  types. Its simplistic API (defined in <filename>gobject/gvalue.h</filename>) can be 
	  used to invoke the value_table functions registered
	  during type registration: for example <function>g_value_copy</function> copies the 
	  content of a <type>GValue</type> to another <type>GValue</type>. This is similar
	  to a C++ assignment which invokes the C++ copy operator to modify the default
	  bit-by-bit copy semantics of C++/C structures/classes.
	</para>

	<para>
	  The following code shows shows you can copy around a 64 bit integer, as well as a <type>GObject</type>
	  instance pointer (sample code for this is located in the source tarball for this document in 
          <filename>sample/gtype/test.c</filename>):
<programlisting>
static void test_int (void)
{
  GValue a_value = {0, }; 
  GValue b_value = {0, };
  guint64 a, b;

  a = 0xdeadbeaf;

  g_value_init (&amp;a_value, G_TYPE_UINT64);
  g_value_set_uint64 (&amp;a_value, a);

  g_value_init (&amp;b_value, G_TYPE_UINT64);
  g_value_copy (&amp;a_value, &amp;b_value);

  b = g_value_get_uint64 (&amp;b_value);

  if (a == b) {
    g_print ("Yay !! 10 lines of code to copy around a uint64.\n");
  } else {
    g_print ("Are you sure this is not a Z80 ?\n");
  }
}

static void test_object (void)
{
  GObject *obj;
  GValue obj_vala = {0, };
  GValue obj_valb = {0, };
  obj = g_object_new (MAMAN_BAR_TYPE, NULL);

  g_value_init (&amp;obj_vala, MAMAN_BAR_TYPE);
  g_value_set_object (&amp;obj_vala, obj);

  g_value_init (&amp;obj_valb, G_TYPE_OBJECT);

  /* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.
     This function thus calls g_object_ref.
     It is interesting to note that the assignment works here because
     MAMAN_BAR_TYPE is a G_TYPE_OBJECT.
   */
  g_value_copy (&amp;obj_vala, &amp;obj_valb);

  g_object_unref (G_OBJECT (obj));
  g_object_unref (G_OBJECT (obj));
}
</programlisting>
	  The important point about the above code is that the exact semantic of the copy calls
	  is undefined since they depend on the implementation of the copy function. Certain 
	  copy functions might decide to allocate a new chunk of memory and then to copy the 
	  data from the source to the destination. Others might want to simply increment
	  the reference count of the instance and copy the reference to the new GValue.
	</para>

	<para>
	  The value_table used to specify these assignment functions is defined in
	  <filename>gtype.h</filename> and is thoroughly described in the
	  API documentation provided with GObject (for once ;-) which is why we will
	  not detail its exact semantics. 
	  <programlisting>
typedef struct _GTypeValueTable         GTypeValueTable;
struct _GTypeValueTable
{
  void     (*value_init)         (GValue       *value);
  void     (*value_free)         (GValue       *value);
  void     (*value_copy)         (const GValue *src_value,
				  GValue       *dest_value);
  /* varargs functionality (optional) */
  gpointer (*value_peek_pointer) (const GValue *value);
  gchar	    *collect_format;
  gchar*   (*collect_value)      (GValue       *value,
				  guint         n_collect_values,
				  GTypeCValue  *collect_values,
				  guint		collect_flags);
  gchar	    *lcopy_format;
  gchar*   (*lcopy_value)        (const GValue *value,
				  guint         n_collect_values,
				  GTypeCValue  *collect_values,
				  guint		collect_flags);
};
	  </programlisting>
	  Interestingly, it is also very unlikely
	  you will ever need to specify a value_table during type registration
	  because these value_tables are inherited from the parent types for
	  non-fundamental types which means that unless you want to write a 
	  fundamental type (not a great idea !), you will not need to provide
	  a new value_table since you will inherit the value_table structure
	  from your parent type.
	</para>
      </sect1>

      <sect1 id="gtype-conventions">
	<title>Conventions</title>


      <para>
	There are a number of conventions users are expected to follow when creating new types
	which are to be exported in a header file:
	<itemizedlist>
	  <listitem><para>
	      Use the <function>object_method</function> pattern for function names: to invoke
	      the method named foo on an instance of object type bar, call 
	      <function>bar_foo</function>.
	    </para></listitem>
	  <listitem><para>Use prefixing to avoid namespace conflicts with other projects.
	      If your library (or application) is named <emphasis>Maman</emphasis>, 
	      prefix all your function names with <emphasis>maman_</emphasis>.
	      For example: <function>maman_object_method</function>.
	    </para></listitem>
	  <listitem><para>Create a macro named <function>PREFIX_OBJECT_TYPE</function> which always 
	      returns the Gtype for the associated object type. For an object of type 
	      <emphasis>Bar</emphasis> in a libray prefixed by <emphasis>maman</emphasis>, 
	      use: <function>MAMAN_BAR_TYPE</function>.
	      It is common although not a convention to implement this macro using either a global 
	      static variable or a function named <function>prefix_object_get_type</function>.
	      We will follow the function pattern wherever possible in this document.
	    </para></listitem>
	  <listitem><para>Create a macro named <function>PREFIX_OBJECT (obj)</function> which 
	      returns a pointer of type <type>PrefixObject</type>. This macro is used to enforce
	      static type safety by doing explicit casts wherever needed. It also enforces
	      dynamic type safety by doing runtime checks. It is expected that in production
	      builds, the dynamic type checks are disabled: they should be used only in 
	      development environments. For example, we would create 
	      <function>MAMAN_BAR (obj)</function> to keep the previous example.
	    </para></listitem>
	  <listitem><para>If the type is classed, create a macro named 
	      <function>PREFIX_OBJECT_CLASS (klass)</function>. This macro
		is strictly equivalent to the previous casting macro: it does static casting with
		dynamic type checking of class structures. It is expected to return a pointer
		to a class structure of type <type>PrefixObjectClass</type>. Again, an example is:
		<function>MAMAN_BAR_CLASS</function>.</para></listitem>
	  <listitem><para>Create a macro named <function>PREFIX_IS_BAR (obj)</function>: this macro is expected
		to return a <type>gboolean</type> which indicates whether or not the input
		object instance pointer of type BAR.</para></listitem>
	  <listitem><para>If the type is classed, create a macro named
	      <function>PREFIX_IS_OBJECT_CLASS (klass)</function> which, as above, returns a boolean
	      if the input class pointer is a pointer to a class of type OBJECT.
	    </para></listitem>
	  <listitem><para>If the type is classed, create a macro named 
	      <function>PREFIX_OBJECT_GET_CLASS (obj)</function>
	    which returns the class pointer associated to an instance of a given type. This macro
	    is used for static and dynamic type safety purposes (just like the previous casting
	    macros).</para></listitem>
	</itemizedlist>
	The implementation of these macros is pretty straightforward: a number of simple-to-use 
	macros are provided in <filename>gtype.h</filename>. For the example we used above, we would 
	write the following trivial code to declare the macros:
<programlisting>
#define MAMAN_BAR_TYPE		  (maman_bar_get_type ())
#define MAMAN_BAR(obj)		  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_BAR_TYPE, MamanBar))
#define MAMAN_BAR_CLASS(klass)	  (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_BAR_TYPE, MamanBarClass))
#define MAMAN_IS_BAR(obj)	  (G_TYPE_CHECK_TYPE ((obj), MAMAN_BAR_TYPE))
#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_BAR_TYPE))
#define MAMAN_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_BAR_TYPE, MamanBarClass))
</programlisting>
      </para>

      <para>
	The following code shows how to implement the <function>maman_bar_get_type</function>
	function:
<programlisting>
GType maman_bar_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      /* You fill this structure. */
    };
    type = g_type_register_static (G_TYPE_OBJECT,
                                   "MamanBarType",
                                   &amp;info, 0);
  }
  return type;
}
</programlisting>
      </para>

      </sect1>

      <sect1 id="gtype-non-instantiable">
	<title>Non-Instantiable non-classed fundamental types</title>

	<para>
	  A lot of types are not instantiable by the type system and do not have
	  a class. Most of these types are fundamental trivial types such as <emphasis>gchar</emphasis>, 
	  registered in <function>g_value_types_init</function> (in <filename>gvaluetypes.c</filename>).
	</para>

	<para>
	  To register such a type in the type system, you just need to fill the 
	  <type>GTypeInfo</type> structure with zeros since these types are also most of the time
	  fundamental:
	  <programlisting>
  GTypeInfo info = {
    0,				/* class_size */
    NULL,			/* base_init */
    NULL,			/* base_destroy */
    NULL,			/* class_init */
    NULL,			/* class_destroy */
    NULL,			/* class_data */
    0,				/* instance_size */
    0,				/* n_preallocs */
    NULL,			/* instance_init */
    NULL,			/* value_table */
  };
  static const GTypeValueTable value_table = {
    value_init_long0,		/* value_init */
    NULL,			/* value_free */
    value_copy_long0,		/* value_copy */
    NULL,			/* value_peek_pointer */
    "i",			/* collect_format */
    value_collect_int,	/* collect_value */
    "p",			/* lcopy_format */
    value_lcopy_char,		/* lcopy_value */
  };
  info.value_table = &amp;value_table;
  type = g_type_register_fundamental (G_TYPE_CHAR, "gchar", &amp;info, &amp;finfo, 0);
	  </programlisting>
	</para>


	<para>
	  Having non-instantiable types might seem a bit useless: what good is a type
	  if you cannot instanciate an instance of that type ? Most of these types
	  are used in conjunction with <type>GValue</type>s: a GValue is initialized
	  with an integer or a string and it is passed around by using the registered 
	  type's value_table. <type>GValue</type>s (and by extension these trivial fundamental
	  types) are most useful when used in conjunction with object properties and signals.
	</para>

      </sect1>

      <sect1 id="gtype-instantiable-classed">
	<title>Instantiable classed types: objects</title>

	<para>
	  Types which are registered with a class and are declared instantiable are
	  what most closely resembles an <emphasis>object</emphasis>. The code below
	  shows how you could register such a type in the type system:
<programlisting>
typedef struct {
  Object parent;
  /* instance members */
  int field_a;
} MamanBar;

struct _MamanBarClass {
  GObjectClass parent;
  /* class members */
  void (*do_action_public_virtual) (MamanBar *self, guint8 i);

  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);
};

#define MAMAN_BAR_TYPE (maman_bar_get_type ())

GType 
maman_bar_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      sizeof (MamanBarClass),
      NULL,           /* base_init */
      NULL,           /* base_finalize */
      (GClassInitFunc) foo_class_init,
      NULL,           /* class_finalize */
      NULL,           /* class_data */
      sizeof (MamanBar),
      0,              /* n_preallocs */
      (GInstanceInitFunc) NULL /* instance_init */
    };
    type = g_type_register_fundamental (G_TYPE_OBJECT,
                                        "BarType",
                                        &amp;info, 0);
  }
  return type;
}
</programlisting>
	  Upon the first call to <function>maman_bar_get_type</function>, the type named
          <emphasis>BarType</emphasis> will be registered in the type system as inheriting
          from the type <emphasis>G_TYPE_OBJECT</emphasis>.
	</para>

	<para>
	  Every object must define two structures: its class structure and its 
	  instance structure. All class structures must contain as first member
	  a <type>GTypeClass</type> structure. All instance structures must contain as first
	  member a <type>GTypeInstance</type> structure. The declaration of these C types,
          coming from <filename>gtype.h</filename> is shown below:
<programlisting>
struct _GTypeClass
{
  GType g_type;
};
struct _GTypeInstance
{
  GTypeClass *g_class;
};
</programlisting>
	  These constraints allow the type system to make sure that every object instance
	  (identified by a pointer to the object's instance structure) contains in its
	  first bytes a pointer to the object's class structure.
	</para>
	<para>
	  This relationship is best explained by an example: let's take object B which
	  inherits from object A:
<programlisting>
/* A definitions */
typedef struct {
  GTypeInstance parent;
  int field_a;
  int field_b;
} A;
typedef struct {
  GTypeClass parent_class;
  void (*method_a) (void);
  void (*method_b) (void);
} AClass;

/* B definitions. */
typedef struct {
  A parent;
  int field_c;
  int field_d;
} B;
typedef struct {
  AClass parent_class;
  void (*method_c) (void);
  void (*method_d) (void);
} BClass;
</programlisting>	  
	  The C standard mandates that the first field of a C structure is stored starting
	  in the first byte of the buffer used to hold the structure's fields in memory.
	  This means that the first field of an instance of an object B is A's first field
	  which in turn is GTypeInstance's first field which in turn is g_class, a pointer
	  to B's class structure.
	</para>

	<para>
	  Thanks to these simple conditions, it is possible to detect the type of every
	  object instance by doing: 
<programlisting>
B *b;
b->parent.parent_class->g_class.g_type
</programlisting>
	  or, more quickly:
<programlisting>
B *b;
((GTypeInstance*)b)->g_class.g_type
</programlisting>
	</para>

	<para>
	  Instanciation of these types can be done with <function>g_type_create_instance</function>:
<programlisting>
GTypeInstance*   g_type_create_instance         (GType               type);
void             g_type_free_instance           (GTypeInstance      *instance);
</programlisting>
	  <function>g_type_create_instance</function> will lookup the type information
	  structure associated to the type requested. Then, the instance size and instanciation
	  policy (if the n_preallocs field is set to a non-zero value, the type system allocates
	  the object's instance structures in chunks rather than mallocing for every instance)
	  declared by the user are used to get a buffer to hold the object's instance
	  structure.
	</para>

	<para>
	  If this is the first instance of the object ever created, the type system must create
	  a class structure: it allocates a buffer to hold the object's class structure and
	  initializes it. It first copies the parent's class structure over this structure
	  (if there is no parent, it initializes it to zero). It then invokes the 
	  base_class_initialization functions (<type>GBaseInitFunc</type>) from topmost 
	  fundamental object to bottom-most most derived object. The object's class_init 
	  (<type>GClassInitFunc</type>) function is invoked afterwards to complete
	  initialization of the class structure.
	  Finally, the object's interfaces are initialized (we will discuss interface initialization
	  in more detail later).
<footnote id="class-init">
<para>
The class initialization process is entirely implemented in 
<function>type_class_init_Wm</function> in <filename>gtype.c</filename>.
</para>
</footnote>
	</para>

	<para>
	  Once the type system has a pointer to an initialized class structure, it sets the object's
	  instance class pointer to the object's class structure and invokes the object's
	  instance_init (<type>GInstanceInitFunc</type>)functions, from top-most fundamental 
	  type to bottom-most most derived type.
	</para>

	<para>
	  Object instance destruction through <function>g_type_free_instance</function> is very simple:
	  the instance structure is returned to the instance pool if there is one and if this was the
	  last living instance of the object, the class is destroyed.
	</para>

	<para>
	  Class destruction (called finalization in Gtype) is the symmetric process of the initialization:
	  it is implemented in <function>type_data_finalize_class_U</function> (in <filename>gtype.c
	  </filename>, as usual...). Interfaces are first destroyed. Then, the most derived 
	  class_finalize (<type>ClassFinalizeFunc</type>) function is invoked. The 
	  base_class_finalize (<type>GBaseFinalizeFunc</type>) functions are 
	  Finally invoked from bottom-most most-derived type to top-most fundamental type and 
	  the class structure is freed.
	</para>

      <para>
	As many readers have now understood it, the base initialization/finalization process is
	very similar to the C++ Constructor/Destructor paradigm. The practical details are quite different
        though and it is important not to get confused by the superficial similarities. Typically, what 
        most users have grown to know as a C++ constructor (that is, a list of
        object methods invoked on the object instance once for each type of the inheritance hierachy) does
        not exist in GType and must be built on top of the facilities offered by GType. Similarly,
        GTypes have no instance destruction mechanism. It is
	the user's responsibility to implement correct destruction semantics on top
	of the existing GType code. (this is what GObject does. See 
	<xref linkend="chapter-gobject"/>)
      </para>

      <para>
       For example, if the object B which derives from A is instantiated, GType will only invoke the 
       instance_init callback of object B while a C++ runtime will invoke the constructor of the object 
       type A first and then of the object type B. Furthermore, the C++ code equivalent to the base_init 
       and class_init callbacks of GType is usually not needed because C++ cannot really create object 
       types at runtime.
      </para>

	<para>
	  The instanciation/finalization process can be summarized as follows:
	<table>
	  <title>GType Instantiation/Finalization</title>
	  <tgroup cols="3">
	    <colspec colwidth="*" colnum="1" align="left"/>
	    <colspec colwidth="*" colnum="2" align="left"/>
	    <colspec colwidth="8*" colnum="3" align="left"/>

	    <thead>
	      <row>
		<entry>Invocation time</entry>
		<entry>Function Invoked</entry>
		<entry>Function's parameters</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>First call to <function>g_type_create_instance</function> for target type</entry>
		<entry>type's base_init function</entry>
		<entry>On the inheritance tree of classes from fundamental type to target type. 
		  base_init is invoked once for each class structure.</entry>
	      </row>
	      <row>
		<entry>First call to <function>g_type_create_instance</function> for target type</entry>
		<entry>target type's class_init function</entry>
		<entry>On target type's class structure</entry>
	      </row>
	      <row>
		<entry>First call to <function>g_type_create_instance</function> for target type</entry>
		<entry colspan="2">interface initialization, see 
		  <xref linkend="gtype-non-instantiable-classed-init"></xref></entry>
	      </row>
	      <row>
		<entry>Each call to <function>g_type_create_instance</function> for target type</entry>
		<entry>target type's instance_init function</entry>
		<entry>On object's instance</entry>
	      </row>
	      <row>
		<entry>Last call to <function>g_type_free_instance</function> for target type</entry>
		<entry colspan="2">interface destruction, see
		  <xref linkend="gtype-non-instantiable-classed-dest"></xref></entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Last call to <function>g_type_free_instance</function> for target type</entry>
		<entry>target type's class_finalize function</entry>
		<entry>On target type's class structure</entry>
	      </row>
	      <row>
		<entry>Last call to <function>g_type_free_instance</function> for target type</entry>
		<entry>type's base_finalize function</entry>
		<entry>On the inheritance tree of classes from fundamental type to target type. 
		  base_init is invoked once for each class structure.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	</para>

      </sect1>

      <sect1 id="gtype-non-instantiable-classed">
	<title>Non-instantiable classed types: Interfaces.</title>

	<para>
	  GType's Interfaces are very similar to Java's interfaces. To declare one of these
	  you have to register a non-instantiable classed type which derives from 
	  GTypeInterface. The following piece of code declares such an interface.
<programlisting>
#define MAMAN_IBAZ_TYPE             (maman_ibaz_get_type ())
#define MAMAN_IBAZ(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_IBAZ_TYPE, MamanIbaz))
#define MAMAN_IBAZ_CLASS(vtable)    (G_TYPE_CHECK_CLASS_CAST ((vtable), MAMAN_IBAZ_TYPE, MamanIbazClass))
#define MAMAN_IS_IBAZ(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_IBAZ_TYPE))
#define MAMAN_IS_IBAZ_CLASS(vtable) (G_TYPE_CHECK_CLASS_TYPE ((vtable), MAMAN_IBAZ_TYPE))
#define MAMAN_IBAZ_GET_CLASS(inst)  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_IBAZ_TYPE, MamanIbazClass))

typedef struct _MamanIbaz MamanIbaz; /* dummy object */
typedef struct _MamanIbazClass MamanIbazClass;

struct _MamanIbazClass {
  GTypeInterface parent;

  void (*do_action) (MamanIbaz *self);
};

GType maman_ibaz_get_type (void);

void maman_ibaz_do_action (MamanIbaz *self);
</programlisting>
          The interface function, <function>maman_ibaz_do_action</function> is implemented
          in a pretty simple way:
<programlisting>
void maman_ibaz_do_action (MamanIbaz *self)
{
  MAMAN_IBAZ_GET_CLASS (self)->do_action (self);
}
</programlisting>
         <function>maman_ibaz_get_gtype</function> registers a type named <emphasis>MamanIBaz</emphasis>
         which inherits from G_TYPE_INTERFACE. All interfaces must be children of G_TYPE_INTERFACE in the 
         inheritance tree.
        </para>

	<para>
	  An interface is defined by only one structure which must contain as first member
	  a <type>GTypeInterface</type> structure. The interface structure is expected to
	  contain the function pointers of the interface methods. It is good style to 
	  define helper functions for each of the interface methods which simply call
	  the interface' method directly: <function>maman_ibaz_do_action</function>
	  is one of these.
	</para>

	<para>
	  Once an interface type is registered, you must register implementations for these
          interfaces. The function named <function>maman_baz_get_type</function> registers
          a new GType named MamanBaz which inherits from <type>GObject</type> and which
          implements the interface <type>MamanIBaz</type>.
<programlisting>
static void maman_baz_do_action (MamanIbaz *self)
{
  g_print ("Baz implementation of IBaz interface Action.\n");
}


static void
baz_interface_init (gpointer         g_iface,
                    gpointer         iface_data)
{
  MamanIbazClass *klass = (MamanIbazClass *)g_iface;
  klass->do_action = maman_baz_do_action;
}

GType 
maman_baz_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      sizeof (MamanBazClass),
      NULL,   /* base_init */
      NULL,   /* base_finalize */
      NULL,   /* class_init */
      NULL,   /* class_finalize */
      NULL,   /* class_data */
      sizeof (MamanBaz),
      0,      /* n_preallocs */
      NULL    /* instance_init */
    };
    static const GInterfaceInfo ibaz_info = {
      (GInterfaceInitFunc) baz_interface_init,    /* interface_init */
      NULL,               /* interface_finalize */
      NULL          /* interface_data */
    };
    type = g_type_register_static (G_TYPE_OBJECT,
                                   "MamanBazType",
                                   &amp;info, 0);
    g_type_add_interface_static (type,
                                 MAMAN_IBAZ_TYPE,
                                 &amp;ibaz_info);
  }
  return type;
}
</programlisting>
	</para>

	<para>
	  <function>g_type_add_interface_static</function> records in the type system that
	  a given type implements also <type>FooInterface</type> 
	  (<function>foo_interface_get_type</function> returns the type of 
	  <type>FooInterface</type>). The <type>GInterfaceInfo</type> structure holds
	  information about the implementation of the interface:
<programlisting>
struct _GInterfaceInfo
{
  GInterfaceInitFunc     interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer               interface_data;
};
</programlisting>
	</para>

	<sect2 id="gtype-non-instantiable-classed-init">
	  <title>Interface Initialization</title>

	  <para>
	    When an instantiable classed type which registered an interface implementation
	    is created for the first time, its class structure is initialized following the process
	    described in <xref linkend="gtype-instantiable-classed"></xref>. Once the class structure is 
	      initialized,the function <function>type_class_init_Wm</function> (implemented in <filename>
	      gtype.c</filename>) initializes the interface implementations associated with
	      that type by calling <function>type_iface_vtable_init_Wm</function> for each
	      interface.
	  </para>

	  <para>
	    First a memory buffer is allocated to hold the interface structure. The parent's
	    interface structure is then copied over to the new interface structure (the parent
	    interface is already initialized at that point). If there is no parent interface,
	    the interface structure is initialized with zeros. The g_type and the g_instance_type
	    fields are then initialized: g_type is set to the type of the most-derived interface
	    and g_instance_type is set to the type of the most derived type which implements 
	    this interface.
	  </para>

	  <para>
	    Finally, the interface' most-derived <function>base_init</function> function and then 
	    the implementation's <function>interface_init</function>
	    function are invoked. It is important to understand that if there are multiple 
	    implementations of an interface the <function>base_init</function> and 
	    <function>interface_init</function> functions will be
	    invoked once for each implementation initialized.
	  </para>

	  <para>
	    It is thus common for base_init functions to hold a local static boolean variable
	    which makes sure that the interface type is initialized only once even if there are 
	    multiple implementations of the interface:
<programlisting>
static void
maman_ibaz_base_init (gpointer g_class)
{
  static gboolean initialized = FALSE;

  if (!initialized) {
    /* create interface signals here. */
    initialized = TRUE;
  }
}
</programlisting>
	  </para>

	<para>
	  If you have found the stuff about interface hairy, you are right: it is hairy but
	  there is not much I can do about it. What I can do is summarize what you need to know
	  about interfaces:	  
	</para>

	  <para>
	    The above process can be summarized as follows:
	  <table>
	    <title><function>Interface Initialization</function></title>
	    <tgroup cols="3">
	      <colspec colwidth="*" colnum="1" align="left"/>
	      <colspec colwidth="*" colnum="2" align="left"/>
	      <colspec colwidth="8*" colnum="3" align="left"/>
	      
	      <thead>
		<row>
		  <entry>Invocation time</entry>
		  <entry>Function Invoked</entry>
		  <entry>Function's parameters</entry>
		  <entry>Remark</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>First call to <function>g_type_create_instance</function> for type
		    implementing interface</entry>
		  <entry>interface' base_init function</entry>
		  <entry>On interface' vtable</entry>
		  <entry>Register interface' signals here (use a local static 
		    boolean variable as described above to make sure not to register them
		    twice.).</entry>
		</row>
		<row>
		  <entry>First call to <function>g_type_create_instance</function> for type
		    implementing interface</entry>
		  <entry>interface' interface_init function</entry>
		  <entry>On interface' vtable</entry>
		  <entry>
		    Initialize interface' implementation. That is, initialize the interface 
		    method pointers in the interface structure to the function's implementation.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	  It is highly unlikely (ie: I do not know of <emphasis>anyone</emphasis> who actually 
	  used it) you will ever need other more fancy things such as the ones described in the
	  following section (<xref linkend="gtype-non-instantiable-classed-dest"></xref>).
	</para>
	
	</sect2>
	
	<sect2 id="gtype-non-instantiable-classed-dest">
	  <title>Interface Destruction</title>

	  <para>
	    When the last instance of an instantiable type which registered an interface implementation
	    is destroyed, the interface's implementations associated to the type are destroyed by
	    <function>type_iface_vtable_finalize_Wm</function> (in <filename>gtype.c</filename>).
	  </para>

	  <para>
	    <function>type_iface_vtable_finalize_Wm</function> invokes first the implementation's 
	    <function>interface_finalize</function> function and then the interface's most-derived
	    <function>base_finalize</function> function.
	  </para>

	  <para>
	    Again, it is important to understand, as in 
	    <xref linkend="gtype-non-instantiable-classed-init"></xref>,
	      that both <function>interface_finalize</function> and <function>base_finalize</function>
	      are invoked exactly once for the destruction of each implementation of an interface. Thus,
	      if you were to use one of these functions, you would need to use a static integer variable
	      which would hold the number of instances of implementations of an interface such that
	      the interface's class is destroyed only once (when the integer variable reaches zero).
	  </para>
	  
	<para>
	    The above process can be summarized as follows:
	  <table>
	    <title><function>Interface Finalization</function></title>
	    <tgroup cols="3">
	      <colspec colwidth="*" colnum="1" align="left"/>
	      <colspec colwidth="*" colnum="2" align="left"/>
	      <colspec colwidth="8*" colnum="3" align="left"/>
	      
	      <thead>
		<row>
		  <entry>Invocation time</entry>
		  <entry>Function Invoked</entry>
		  <entry>Function's parameters</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>Last call to <function>g_type_free_instance</function> for type
		    implementing interface</entry>
		  <entry>interface' interface_finalize function</entry>
		  <entry>On interface' vtable</entry>
		</row>
		<row>
		  <entry>Last call to <function>g_type_free_instance</function>for type
		    implementing interface</entry>
		  <entry>interface' base_finalize function</entry>
		  <entry>On interface' vtable</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	  
	<para>
	  Now that you have read this section, you can forget about it. Please, forget it
	  <emphasis>as soon as possible</emphasis>.
	</para>

      </sect2>
      
    </sect1>
    
  </chapter>
