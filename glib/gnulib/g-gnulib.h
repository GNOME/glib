/* GLIB - Library of useful routines for C programming
 * Copyright (C) 2003  Matthias Clasen
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __G_GNULIB_H__

#include "config.h"
#include <stdlib.h>
#include <stdint.h>
#include "glib/glib.h"

/* Private namespace for gnulib functions */
#define asnprintf        _g_gnulib_asnprintf
#define vasnprintf       _g_gnulib_vasnprintf
#define printf_parse     _g_gnulib_printf_parse
#define printf_fetchargs _g_gnulib_printf_fetchargs

/* Use GLib memory allocation */
#undef malloc
#undef realloc
#undef free
#define malloc  g_malloc
#define realloc g_realloc
#define free    g_free

/* Ensure only C99 snprintf gets used */
#undef HAVE_SNPRINTF
#ifdef HAVE_C99_SNPRINTF
#define HAVE_SNPRINTF 1
#else
#define HAVE_SNPRINTF 0
#endif

#define _GL_CONFIG_H_INCLUDED 1

/* Add declarations that are normally generated by autoconf */

/* Define _GL_HAS_ATTRIBUTE only once, because on FreeBSD, with gcc < 5, if
   <config.h> gets included once again after <sys/cdefs.h>, __has_attribute(x)
   expands to 0 always, and redefining _GL_HAS_ATTRIBUTE would turn off all
   attributes.  */
#ifndef _GL_HAS_ATTRIBUTE
# if (defined __has_attribute \
      && (!defined __clang_minor__ \
          || (defined __apple_build_version__ \
              ? 7000000 <= __apple_build_version__ \
              : 5 <= __clang_major__)))
#  define _GL_HAS_ATTRIBUTE(attr) __has_attribute (__##attr##__)
# else
#  define _GL_HAS_ATTRIBUTE(attr) _GL_ATTR_##attr
#  define _GL_ATTR_alloc_size _GL_GNUC_PREREQ (4, 3)
#  define _GL_ATTR_always_inline _GL_GNUC_PREREQ (3, 2)
#  define _GL_ATTR_artificial _GL_GNUC_PREREQ (4, 3)
#  define _GL_ATTR_cold _GL_GNUC_PREREQ (4, 3)
#  define _GL_ATTR_const _GL_GNUC_PREREQ (2, 95)
#  define _GL_ATTR_deprecated _GL_GNUC_PREREQ (3, 1)
#  define _GL_ATTR_diagnose_if 0
#  define _GL_ATTR_error _GL_GNUC_PREREQ (4, 3)
#  define _GL_ATTR_externally_visible _GL_GNUC_PREREQ (4, 1)
#  define _GL_ATTR_fallthrough _GL_GNUC_PREREQ (7, 0)
#  define _GL_ATTR_format _GL_GNUC_PREREQ (2, 7)
#  define _GL_ATTR_leaf _GL_GNUC_PREREQ (4, 6)
#  define _GL_ATTR_malloc _GL_GNUC_PREREQ (3, 0)
#  ifdef _ICC
#   define _GL_ATTR_may_alias 0
#  else
#   define _GL_ATTR_may_alias _GL_GNUC_PREREQ (3, 3)
#  endif
#  define _GL_ATTR_noinline _GL_GNUC_PREREQ (3, 1)
#  define _GL_ATTR_nonnull _GL_GNUC_PREREQ (3, 3)
#  define _GL_ATTR_nonstring _GL_GNUC_PREREQ (8, 0)
#  define _GL_ATTR_nothrow _GL_GNUC_PREREQ (3, 3)
#  define _GL_ATTR_packed _GL_GNUC_PREREQ (2, 7)
#  define _GL_ATTR_pure _GL_GNUC_PREREQ (2, 96)
#  define _GL_ATTR_returns_nonnull _GL_GNUC_PREREQ (4, 9)
#  define _GL_ATTR_sentinel _GL_GNUC_PREREQ (4, 0)
#  define _GL_ATTR_unused _GL_GNUC_PREREQ (2, 7)
#  define _GL_ATTR_warn_unused_result _GL_GNUC_PREREQ (3, 4)
# endif
#endif

/* _GL_ATTRIBUTE_FALLTHROUGH declares that it is not a programming mistake if
   the control flow falls through to the immediately following 'case' or
   'default' label.  The compiler should not warn in this case.  */
/* Applies to: Empty statement (;), inside a 'switch' statement.  */
/* Always expands to something.  */
#ifndef _GL_ATTRIBUTE_FALLTHROUGH
# if _GL_HAVE___HAS_C_ATTRIBUTE
#  if __has_c_attribute (__fallthrough__)
#   define _GL_ATTRIBUTE_FALLTHROUGH [[__fallthrough__]]
#  endif
# endif
# if !defined _GL_ATTRIBUTE_FALLTHROUGH && _GL_HAS_ATTRIBUTE (fallthrough)
#  define _GL_ATTRIBUTE_FALLTHROUGH __attribute__ ((__fallthrough__))
# endif
# ifndef _GL_ATTRIBUTE_FALLTHROUGH
#  define _GL_ATTRIBUTE_FALLTHROUGH ((void) 0)
# endif
#endif

#ifndef _GL_ATTRIBUTE_FORMAT
# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7) || defined __clang__
#  define _GL_ATTRIBUTE_FORMAT(spec) __attribute__ ((__format__ spec))
# else
#  define _GL_ATTRIBUTE_FORMAT(spec) /* empty */
# endif
#endif

/* An __attribute__ __format__ specifier for a function that takes a format
   string and arguments, where the format string directives are the ones
   standardized by ISO C99 and POSIX.
   _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD  */
/* __gnu_printf__ is supported in GCC >= 4.4.  */
#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
# define _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD __gnu_printf__
#else
# define _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD __printf__
#endif

/* The __attribute__ feature is available in gcc versions 2.5 and later.
   The attribute __pure__ was added in gcc 2.96.  */
#ifndef _GL_ATTRIBUTE_PURE
# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || defined __clang__
#  define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define _GL_ATTRIBUTE_PURE /* empty */
# endif
#endif

/* In GCC 4.6 (inclusive) to 5.1 (exclusive),
   suppress bogus "no previous prototype for 'FOO'"
   and "no previous declaration for 'FOO'" diagnostics,
   when FOO is an inline function in the header; see
   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54113> and
   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63877>.  */
#if __GNUC__ == 4 && 6 <= __GNUC_MINOR__
# if defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__
#  define _GL_INLINE_HEADER_CONST_PRAGMA
# else
#  define _GL_INLINE_HEADER_CONST_PRAGMA \
     _Pragma ("GCC diagnostic ignored \"-Wsuggest-attribute=const\"")
# endif
# define _GL_INLINE_HEADER_BEGIN \
    _Pragma ("GCC diagnostic push") \
    _Pragma ("GCC diagnostic ignored \"-Wmissing-prototypes\"") \
    _Pragma ("GCC diagnostic ignored \"-Wmissing-declarations\"") \
    _GL_INLINE_HEADER_CONST_PRAGMA
# define _GL_INLINE_HEADER_END \
    _Pragma ("GCC diagnostic pop")
#else
# define _GL_INLINE_HEADER_BEGIN
# define _GL_INLINE_HEADER_END
#endif

#if ((__GNUC__ \
      ? (defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__ \
         && !defined __PCC__) \
      : (199901L <= __STDC_VERSION__ \
         && !defined __HP_cc \
         && !defined __PGI \
         && !(defined __SUNPRO_C && __STDC__))) \
     && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
# define _GL_INLINE inline
# define _GL_EXTERN_INLINE extern inline
# define _GL_EXTERN_INLINE_IN_USE
#elif (2 < __GNUC__ + (7 <= __GNUC_MINOR__) && !defined __STRICT_ANSI__ \
       && !defined __PCC__ \
       && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
# if defined __GNUC_GNU_INLINE__ && __GNUC_GNU_INLINE__
   /* __gnu_inline__ suppresses a GCC 4.2 diagnostic.  */ 
#  define _GL_INLINE extern inline __attribute__ ((__gnu_inline__))
# else
#  define _GL_INLINE extern inline
# endif
# define _GL_EXTERN_INLINE extern
# define _GL_EXTERN_INLINE_IN_USE
#else
# define _GL_INLINE _GL_UNUSED static
# define _GL_EXTERN_INLINE _GL_UNUSED static
#endif

#include "arg-nonnull.h"

#include "wchar.h"

/* Override mbstate_t if it is too small.
   On IRIX 6.5, sizeof (mbstate_t) == 1, which is not sufficient for
   implementing mbrtowc for encodings like UTF-8.
   On AIX and MSVC, mbrtowc needs to be overridden, but mbstate_t exists and is
   large enough and overriding it would cause problems in C++ mode.  */  
#if !(defined _WIN32 && !defined __CYGWIN__) && \
 (!defined ____mbstate_t_defined || ____mbstate_t_defined)
# if !GNULIB_defined_mbstate_t
#  if !(defined _AIX || defined _MSC_VER)
typedef int rpl_mbstate_t;
#   undef mbstate_t
#   define mbstate_t rpl_mbstate_t
#  endif
#  define GNULIB_defined_mbstate_t 1
# endif
#endif

/* ISO C 23 ยง 7.31.6.(3) says that zeroing an mbstate_t is a way to put the
   mbstate_t into an initial state.  However, on many platforms an mbstate_t
   is large, and it is possible - as an optimization - to get away with zeroing
   only part of it.  So, instead of

        mbstate_t state = { 0 };

   or

        mbstate_t state;
        memset (&state, 0, sizeof (mbstate_t));

   we can write this faster code:

        mbstate_t state;
        mbszero (&state);
 */
/* _GL_MBSTATE_INIT_SIZE describes how mbsinit() behaves: It is the number of
   bytes at the beginning of an mbstate_t that need to be zero, for mbsinit()
   to return true.
   _GL_MBSTATE_ZERO_SIZE is the number of bytes at the beginning of an mbstate_t
   that need to be zero,
     - for mbsinit() to return true, and
     - for all other multibyte-aware functions to operate properly.
   0 < _GL_MBSTATE_INIT_SIZE <= _GL_MBSTATE_ZERO_SIZE <= sizeof (mbstate_t).
   These values are determined by source code inspection, where possible, and
   by running the gnulib unit tests.
   We need _GL_MBSTATE_INIT_SIZE because if we define _GL_MBSTATE_ZERO_SIZE
   without considering what mbsinit() does, we get test failures such as
     assertion "mbsinit (&iter->state)" failed
 */

# if GNULIB_defined_mbstate_t                             /* AIX, IRIX */
/* mbstate_t has at least 4 bytes.  They are used as coded in
   gnulib/lib/mbrtowc.c.  */
#  define _GL_MBSTATE_INIT_SIZE 1
/* define _GL_MBSTATE_ZERO_SIZE 4
   does not work: it causes test failures.
   So, use the safe fallback value, below.  */
# elif __GLIBC__ + (__GLIBC_MINOR__ >= 2) > 2             /* glibc */

/* mbstate_t is defined in <bits/types/__mbstate_t.h>.
   For more details, see glibc/iconv/skeleton.c.  */
#  define _GL_MBSTATE_INIT_SIZE 4 /* sizeof (((mbstate_t) {0}).__count) */
#  define _GL_MBSTATE_ZERO_SIZE /* 8 */ sizeof (mbstate_t)
# elif defined MUSL_LIBC                                  /* musl libc */
/* mbstate_t is defined in <bits/alltypes.h>.
   It is an opaque aligned 8-byte struct, of which at most the first
   4 bytes are used.
   For more details, see src/multibyte/mbrtowc.c.  */
#  define _GL_MBSTATE_INIT_SIZE 4 /* sizeof (unsigned) */
#  define _GL_MBSTATE_ZERO_SIZE 4
# elif defined __APPLE__ && defined __MACH__              /* macOS */
/* On macOS, mbstate_t is defined in <machine/_types.h>.
   It is an opaque aligned 128-byte struct, of which at most the first
   12 bytes are used.
   For more details, see the __mbsinit implementations in
   Libc-<version>/locale/FreeBSD/
   {ascii,none,euc,mskanji,big5,gb2312,gbk,gb18030,utf8,utf2}.c.  */
/* File       INIT_SIZE  ZERO_SIZE
   ascii.c        0          0
   none.c         0          0
   euc.c         12         12
   mskanji.c      4          4
   big5.c         4          4
   gb2312.c       4          6
   gbk.c          4          4
   gb18030.c      4          8
   utf8.c         8         10
   utf2.c         8         12 */
#  define _GL_MBSTATE_INIT_SIZE 12
#  define _GL_MBSTATE_ZERO_SIZE 12
# elif defined __FreeBSD__                                /* FreeBSD */
/* On FreeBSD, mbstate_t is defined in src/sys/sys/_types.h.
   It is an opaque aligned 128-byte struct, of which at most the first
   12 bytes are used.
   For more details, see the __mbsinit implementations in
   src/lib/libc/locale/
   {ascii,none,euc,mskanji,big5,gb2312,gbk,gb18030,utf8}.c.  */
/* File       INIT_SIZE  ZERO_SIZE
   ascii.c        0          0
   none.c         0          0
   euc.c         12         12
   mskanji.c      4          4
   big5.c         4          4
   gb2312.c       4          6
   gbk.c          4          4
   gb18030.c      4          8
   utf8.c         8         12 */
#  define _GL_MBSTATE_INIT_SIZE 12
#  define _GL_MBSTATE_ZERO_SIZE 12
# elif defined __NetBSD__                                 /* NetBSD */
/* On NetBSD, mbstate_t is defined in src/sys/sys/ansi.h.
   It is an opaque aligned 128-byte struct, of which at most the first
   28 bytes are used.
   For more details, see the *State types in
   src/lib/libc/citrus/modules/citrus_*.c
   (ignoring citrus_{hz,iso2022,utf7,viqr,zw}.c, since these implement
   stateful encodings, not usable as locale encodings).  */
/* File                                ZERO_SIZE
   citrus/citrus_none.c                    0
   citrus/modules/citrus_euc.c             8
   citrus/modules/citrus_euctw.c           8
   citrus/modules/citrus_mskanji.c         8
   citrus/modules/citrus_big5.c            8
   citrus/modules/citrus_gbk2k.c           8
   citrus/modules/citrus_dechanyu.c        8
   citrus/modules/citrus_johab.c           6
   citrus/modules/citrus_utf8.c           12 */
/* But 12 is not the correct value for _GL_MBSTATE_ZERO_SIZE: we get test
   failures for values < 28.  */
#  define _GL_MBSTATE_ZERO_SIZE 28
# elif defined __OpenBSD__                                /* OpenBSD */
/* On OpenBSD, mbstate_t is defined in src/sys/sys/_types.h.
   It is an opaque aligned 128-byte struct, of which at most the first
   12 bytes are used.
   For more details, see src/lib/libc/citrus/citrus_*.c.  */
/* File           INIT_SIZE  ZERO_SIZE
   citrus_none.c      0          0
   citrus_utf8.c     12         12 */
#  define _GL_MBSTATE_INIT_SIZE 12
#  define _GL_MBSTATE_ZERO_SIZE 12
# elif defined __minix                                    /* Minix */
/* On Minix, mbstate_t is defined in sys/sys/ansi.h.
   It is an opaque aligned 128-byte struct.
   For more details, see the *State types in
   lib/libc/citrus/citrus_*.c.  */
/* File           INIT_SIZE  ZERO_SIZE
   citrus_none.c      0          0 */
/* But 1 is not the correct value for _GL_MBSTATE_ZERO_SIZE: we get test
   failures for values < 4.  */
#  define _GL_MBSTATE_ZERO_SIZE 4
# elif defined __sun                                      /* Solaris */
/* On Solaris, mbstate_t is defined in <wchar_impl.h>.
   It is an opaque aligned 24-byte or 32-byte struct, of which at most the first
   20 or 28 bytes are used.
   For more details on OpenSolaris derivatives, see the *State types in
   illumos-gate/usr/src/lib/libc/port/locale/
   {none,euc,mskanji,big5,gb2312,gbk,gb18030,utf8}.c.  */
/* File       INIT_SIZE  ZERO_SIZE
   none.c         0          0
   euc.c         12         12
   mskanji.c      4          4
   big5.c         4          4
   gb2312.c       4          6
   gbk.c          4          4
   gb18030.c      4          8
   utf8.c        12         12 */
/* But 12 is not the correct value for _GL_MBSTATE_ZERO_SIZE: we get test
   failures
     - in OpenIndiana and OmniOS: for values < 16,
     - in Solaris 10 and 11: for values < 20 (in 32-bit mode)
       or < 28 (in 64-bit mode).
   Since we don't have a good way to distinguish the OpenSolaris derivatives
   from the proprietary Solaris versions, and can't inspect the Solaris source
   code, use the safe fallback values, below.  */
# elif defined __CYGWIN__                                 /* Cygwin */
/* On Cygwin, mbstate_t is defined in <sys/_types.h>.
   For more details, see newlib/libc/stdlib/mbtowc_r.c and
   winsup/cygwin/strfuncs.cc.  */
#  define _GL_MBSTATE_INIT_SIZE 4 /* sizeof (int) */
#  define _GL_MBSTATE_ZERO_SIZE 8
# elif defined _WIN32 && !defined __CYGWIN__              /* Native Windows.  */
/* MSVC defines 'mbstate_t' as an aligned 8-byte struct.
   On mingw, 'mbstate_t' is sometimes defined as 'int', sometimes defined
   as an aligned 8-byte struct, of which the first 4 bytes matter.
   Use the safe values, below.  */
# elif defined __ANDROID__                                /* Android */
/* Android defines 'mbstate_t' in <bits/mbstate_t.h>.
   It is an opaque 4-byte or 8-byte struct.
   For more details, see
   bionic/libc/private/bionic_mbstate.h
   bionic/libc/bionic/mbrtoc32.cpp
   bionic/libc/bionic/mbrtoc16.cpp
 */
#  define _GL_MBSTATE_INIT_SIZE 4
#  define _GL_MBSTATE_ZERO_SIZE 4
# endif
/* Use safe values as defaults.  */
# ifndef _GL_MBSTATE_INIT_SIZE
#  define _GL_MBSTATE_INIT_SIZE sizeof (mbstate_t)
# endif
# ifndef _GL_MBSTATE_ZERO_SIZE
#  define _GL_MBSTATE_ZERO_SIZE sizeof (mbstate_t)
# endif
#ifdef __cplusplus
extern "C" {
#endif
# if defined IN_MBSZERO
_GL_EXTERN_INLINE
# else
_GL_INLINE
# endif
_GL_ARG_NONNULL ((1)) void
mbszero (mbstate_t *ps)
{
  memset (ps, 0, _GL_MBSTATE_ZERO_SIZE);
}
#ifdef __cplusplus
}
#endif

#endif  /* __G_GNULIB_H__ */
