/* gen-unicode-values.c - generate gunicodevalues.h for glib
 *
 * Author:
 *   Matthias Clasen
 *
 * Copyright (C) 2024 Red Hat, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

typedef struct {
  gunichar ch;
  double value;
} NumericValueEntry;

static NumericValueEntry entries[4000];
static gsize num_entries;

static int
compare_entries (const void *p1, const void *p2)
{
  const NumericValueEntry *e1 = p1;
  const NumericValueEntry *e2 = p2;

  if (e1->ch < e2->ch)
    return -1;
  else if (e1->ch > e2->ch)
    return 1;
  else
    return 0;
}

static void
read_file (FILE *f)
{
  gsize l;
  static char buf[4000];

  l = 0;
  while (fgets (buf, sizeof buf, f))
    {
      gunichar ch, ch1, ch2;
      double value;
      const char *s = buf;
      int k;

      l++;

      while (*s == ' ')
        s++;

      if (s[0] == '#' || s[0] == '\0' || s[0] == '\n')
        continue;

      k = sscanf (s, "%x ; %lf", &ch, &value);
      if (k == 2)
        {
          if (num_entries + 1 > G_N_ELEMENTS (entries))
            {
              fprintf (stderr, "Table overflow\n");
              exit (1);
            }

          entries[num_entries].ch = ch;
          entries[num_entries].value = value;
          num_entries++;
          continue;
        }

      k = sscanf (s, "%x..%x ; %lf", &ch1, &ch2, &value);
      if (k == 3)
        {
          if (num_entries + (ch2 + 1 - ch1) > G_N_ELEMENTS (entries))
            {
              fprintf (stderr, "Table overflow\n");
              exit (1);
            }

          for (ch = ch1; ch <= ch2; ch++)
            {
              entries[num_entries].ch = ch;
              entries[num_entries].value = value;
              num_entries++;
            }
          continue;
        }

      fprintf (stderr, "Malformed line: %s\n", s);
      exit (1);
    }

  qsort (entries, num_entries, sizeof (NumericValueEntry), compare_entries);
}

static void
read_data (const char *filename)
{
  FILE *f;

  fprintf (stderr, "Reading '%s'\n", filename);

  if (!(f = fopen (filename, "rt")))
    {
      fprintf (stderr, "error: cannot open '%s' for reading", filename);
      exit (1);
    }

  read_file (f);

  fclose (f);
}

static void
gen_unicode_values (void)
{
  fprintf (stderr, "Generating 'gunicodevalues.h'\n");
  printf ("/* gunicodevalues.h\n"
          " * generated by gen-unicode-values\n"
          " * from the file DerivedNumericValues.txt\n"
          " */\n\n");

  printf ("#pragma once\n\n");

  /* We collect ranges of consecutive characters whose
   * numeric values have a fixed distance.
   */
  printf ("typedef struct\n"
          "{\n"
          "  gunichar ch;\n"
          "  guint16 length;\n"
          "  guint16 increment;\n"
          "  double value;\n"
          "} GUnicodeValue;\n\n");

  printf ("static GUnicodeValue unicode_values[] = {\n");

  guint16 increment = 0xffff;
  for (gsize i = 0; i < num_entries; i++)
    {
      if (increment == 0xffff &&
          entries[i + 1].ch == entries[i].ch + 1)
        {
          double delta = entries[i + 1].value - entries[i].value;
          if (delta == ceil (delta) && delta >= 0 && delta < 0xffff)
            increment = (guint16) delta;
        }

      gsize k = i;
      if (increment != 0xffff)
        {
          while (entries[k + 1].ch == entries[k].ch + 1 &&
                 entries[k + 1].value == entries[k].value + increment)
            k++;
        }

      printf ("  { %#x, %u, %u, %f },\n",
              entries[i].ch,
              (guint) (k - i + 1),
              increment != 0xffff ? increment : 0,
              entries[i].value);
      i = k;
      increment = 0xffff;
    }

  printf ("};\n\n");
}

int
main (int argc, const char **argv)
{
  if (argc < 2)
    {
      fprintf (stderr, "usage:\n gen-unicode-values /path/to/DerivedNumericValues.txt\n");
      exit (1);
    }

  read_data (argv[1]);
  gen_unicode_values ();

  return 0;
}
